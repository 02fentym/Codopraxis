{% extends "main.html" %}
{% block title %}Standard I/O Builder{% endblock %}
{% block content %}

<div class="max-w-7xl mx-auto space-y-6">
  <!-- Breadcrumbs -->
  <div class="breadcrumbs text-sm">
    <ul>
      <li><a href="{% url 'home' %}" class="link">Home</a></li>
      <li><span class="opacity-70">Code Questions</span></li>
      <li class="font-semibold">Standard I/O Builder</li>
    </ul>
  </div>

  <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
    <!-- Left: Builder Card -->
    <div class="card bg-base-200">
      <div class="card-body space-y-6">
        <h1 class="card-title text-3xl">Standard I/O Builder</h1>

        <form id="builder-form" method="post" class="space-y-6">
          {% csrf_token %}

          <!-- Hidden: force question_type -->
          <input type="hidden" id="question_type" value="standard_io">

          <!-- Prompt -->
          <div class="form-control">
            <label class="label block">
              <span class="label-text font-medium">
                Prompt <span class="opacity-60 text-xs">(shown to students)</span>
              </span>
            </label>
            <textarea id="prompt" name="prompt" class="textarea textarea-bordered bg-base-100 w-full h-24"
              placeholder="Add two numbers together"></textarea>
            <p class="text-error text-xs mt-1 hidden" id="err_prompt"></p>
          </div>

          <!-- Limits -->
          <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <div class="form-control">
              <label class="label block">
                <span class="label-text font-medium">Timeout (seconds)</span>
              </label>
              <input id="timeout_seconds" type="number" min="1" step="1" class="input input-bordered w-full"
                value="{{ timeout_default }}">
              <p class="text-error text-xs mt-1 hidden" id="err_timeout"></p>
              <label class="label">
                <span class="opacity-60 text-xs">Max time per test execution.</span>
              </label>
            </div>

            <div class="form-control">
              <label class="label block">
                <span class="label-text font-medium">Memory limit (MB)</span>
              </label>
              <input id="memory_limit_mb" type="number" min="16" step="1" class="input input-bordered w-full"
                value="{{ memory_default }}">
              <p class="text-error text-xs mt-1 hidden" id="err_memory"></p>
              <label class="label">
                <span class="opacity-60 text-xs">Max memory per test execution.</span>
              </label>
            </div>
          </div>

          <div class="divider my-0 w-auto text-lg font-bold mb-6">Tests</div>

          <!-- Tests container (JS will render tests here) -->
          <div id="testsContainer" class="space-y-6"></div>

          <!-- Add Test -->
          <div class="flex gap-2 justify-center">
            <button id="addTestBtn" type="button" class="btn btn-primary btn-sm">+ Test</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Right: Preview -->
    <div class="card bg-base-200 lg:sticky lg:top-6 h-fit">
      <div class="card-body space-y-3">
        <h2 class="card-title text-2xl">Preview</h2>

        <!-- What will be saved -->
        <div class="collapse collapse-arrow bg-base-100">
          <input type="checkbox" checked>
          <div class="collapse-title font-semibold">Question payload</div>
          <div class="collapse-content">
            <div class="mockup-code text-xs bg-base-100">
              <pre><code id="questionPreview">{}</code></pre>
            </div>
          </div>
        </div>

        <div class="collapse collapse-arrow bg-base-100">
          <input type="checkbox">
          <div class="collapse-title font-semibold">Standard I/O tests_json</div>
          <div class="collapse-content">
            <div class="mockup-code text-xs bg-base-100">
              <pre><code id="testsPreview">{"tests":[{"name":"test1","stdin":"","stdout":""}]}</code></pre>
            </div>
          </div>
        </div>

        <!-- Actions -->
        <div class="mt-2 flex flex-wrap items-center gap-2">
          <button id="copyJsonBtn" type="button" class="btn btn-outline btn-sm">Copy tests JSON</button>
          <button id="validateBtn" type="button" class="btn btn-primary btn-sm">Validate tests</button>
          <button id="saveBtn" type="button" class="btn btn-success btn-sm">Save</button>
          <span id="newlineBadge" class="badge badge-outline hidden">some stdout will include \n</span>
        </div>

        <!-- Toasts -->
        <div id="toastSaveOk" class="toast toast-end z-50 hidden">
          <div class="alert alert-success"><span>Saved.</span></div>
        </div>
        <div id="toastSaveErr" class="toast toast-end z-50 hidden">
          <div class="alert alert-error"><span>Save failed. Fix errors and try again.</span></div>
        </div>
        <div id="toastOk" class="toast toast-end z-50 hidden">
          <div class="alert alert-success"><span>Tests are valid.</span></div>
        </div>
        <div id="toastErr" class="toast toast-end z-50 hidden">
          <div class="alert alert-error"><span>Tests have issues. See console.</span></div>
        </div>
        <div id="toast" class="toast toast-end z-50 hidden">
          <div class="alert alert-success"><span>Copied to clipboard.</span></div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  (function () {
    const $ = (id) => document.getElementById(id);

    // ----- DOM refs -----
    const promptEl = $("prompt");
    const timeoutEl = $("timeout_seconds");
    const memoryEl = $("memory_limit_mb");

    const errPrompt = $("err_prompt");
    const errTimeout = $("err_timeout");
    const errMemory = $("err_memory");

    const testsContainer = $("testsContainer");
    const questionPreview = $("questionPreview");
    const testsPreview = $("testsPreview");
    const newlineBadge = $("newlineBadge");

    const addTestBtn = $("addTestBtn");
    const copyBtn = $("copyJsonBtn");
    const toastEl = $("toast");
    const validateBtn = $("validateBtn");
    const toastOk = $("toastOk");
    const toastErr = $("toastErr");
    const saveBtn = $("saveBtn");
    const toastSaveOk = $("toastSaveOk");
    const toastSaveErr = $("toastSaveErr");

    // ----- State -----
    let tests = [{ name: "test1", stdin: "", stdout: "" }];
    let currentQuestionId = null; // set after first successful save

    // ----- Utilities -----
    function show(el, ms = 1800) {
      if (!el) return;
      el.classList.remove("hidden");
      setTimeout(() => el.classList.add("hidden"), ms);
    }
    function getCookie(name) {
      const v = document.cookie.split("; ").find(row => row.startsWith(name + "="));
      return v ? decodeURIComponent(v.split("=")[1]) : null;
    }
    const csrftoken = getCookie("csrftoken");
    function sectionNodes() { return [...testsContainer.querySelectorAll("[data-test-index]")]; }

    function clearInlineErrors(section) {
      const nameEl = section.querySelector('[data-role="name"]');
      const stdinEl = section.querySelector('[data-role="stdin"]');
      const stdoutEl = section.querySelector('[data-role="stdout"]');
      const errName = section.querySelector('[data-err="name"]');
      const errStdout = section.querySelector('[data-err="stdout"]');
      [nameEl, stdinEl, stdoutEl].forEach(el => el && el.classList.remove("input-error", "textarea-error"));
      [errName, errStdout].forEach(el => { if (el) { el.textContent = ""; el.classList.add("hidden"); } });
    }
    function clearGlobalErrors() {
      [promptEl, timeoutEl, memoryEl].forEach(el => el && el.classList.remove("input-error", "select-error"));
      [errPrompt, errTimeout, errMemory].forEach(el => { if (el) { el.textContent = ""; el.classList.add("hidden"); } });
    }
    function showFieldError(section, field, message) {
      const map = {
        name: { sel: '[data-role="name"]', errSel: '[data-err="name"]', errorClass: 'input-error' },
        stdout: { sel: '[data-role="stdout"]', errSel: '[data-err="stdout"]', errorClass: 'input-error' },
      };
      const cfg = map[field]; if (!cfg) return;
      const input = section.querySelector(cfg.sel);
      const err = section.querySelector(cfg.errSel);
      if (input) input.classList.add(cfg.errorClass);
      if (err) { err.textContent = message; err.classList.remove("hidden"); }
    }
    function makeUniqueName(base) {
      const existing = new Set(tests.map(t => (t.name || "").trim()).filter(Boolean));
      let candidate = (base || "test").trim();
      if (!existing.has(candidate)) return candidate;
      let i = 1;
      while (existing.has(`${candidate}-copy${i > 1 ? "-" + i : ""}`)) i++;
      return `${candidate}-copy${i > 1 ? "-" + i : ""}`;
    }

    // ----- Renderers -----
    function testSectionTemplate(idx, test) {
      const n = idx + 1;
      const stdinId = `stdin_${n}`;
      const stdoutId = `stdout_${n}`;
      const nameId = `name_${n}`;
      return `
      <div class="space-y-3 border border-2 border-base-100 rounded-box px-4" data-test-index="${idx}">
        <div class="flex items-center justify-between my-2">
          <div class="my-0 w-auto font-medium text-lg">Test #${n}</div>
          <div class="flex items-center gap-1">
            <button type="button" class="btn btn-ghost btn-sm" data-action="duplicateTest" title="Duplicate">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16">
                <path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M11.25 4.25v-2.5h-9.5v9.5h2.5m.5-6.5v9.5h9.5v-9.5z"/>
              </svg>
            </button>
            <button type="button" class="btn btn-ghost btn-sm text-base-content" data-action="removeTest"${tests.length === 1 ? ' disabled' : ''} title="Remove">
              <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1">
                <path d="M4 7h16m-10 4v6m4-6v6M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1-12M9 7V4a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1v3"/>
              </svg>
            </button>
          </div>
        </div>

        <!-- Test name -->
        <div class="form-control">
          <label class="label block">
            <span class="label-text font-medium">Test name</span>
          </label>
          <input id="${nameId}" data-role="name" type="text" class="input input-bordered w-full"
                 placeholder="test${n}" value="${test.name || `test${n}`}" />
          <p class="text-error text-xs mt-1 hidden" data-err="name"></p>
          <label class="label">
            <span class="opacity-60 text-xs">Unique within this question.</span>
          </label>
        </div>

        <!-- stdin -->
        <div class="form-control">
          <label class="label block">
            <span class="label-text font-medium">stdin</span>
          </label>
          <textarea id="${stdinId}" data-role="stdin" class="textarea textarea-bordered bg-base-100 w-full h-20"
                    placeholder="5&#10;4">${test.stdin ?? ""}</textarea>
          <label class="label">
            <span class="opacity-60 text-xs">Multiline OK. Piped to stdin.</span>
          </label>
        </div>

        <!-- stdout -->
        <div class="form-control">
          <label class="label block">
            <span class="label-text font-medium">stdout</span>
          </label>
          <input id="${stdoutId}" data-role="stdout" type="text" class="input input-bordered w-full"
                 placeholder="9" value="${(test.stdout ?? "").replace(/\n$/, "")}" />
          <p class="text-error text-xs mt-1 hidden" data-err="stdout"></p>
          <label class="label mb-4">
            <span class="opacity-60 text-xs">We’ll ensure a trailing newline (<code>\\n</code>) in the spec.</span>
          </label>
        </div>
      </div>
    `;
    }
    function renderTests() { testsContainer.innerHTML = tests.map((t, i) => testSectionTemplate(i, t)).join(""); }

    // ----- Spec builders -----
    function coerceStateFromDOM() {
      const sections = sectionNodes();
      tests = sections.map((section, i) => {
        const nameEl = section.querySelector('[data-role="name"]');
        const stdinEl = section.querySelector('[data-role="stdin"]');
        const stdoutEl = section.querySelector('[data-role="stdout"]');
        const rawStdout = (stdoutEl.value || "");
        const stdout = rawStdout ? (rawStdout.endsWith("\n") ? rawStdout : rawStdout + "\n") : "";
        return {
          name: (nameEl.value || `test${i + 1}`).trim(),
          stdin: stdinEl.value || "",
          stdout: stdout
        };
      });
    }
    function hasContent(t) { return (t.stdin && t.stdin.length) || (t.stdout && t.stdout.length); }
    function parsePositiveInt(el) {
      const v = (el?.value ?? "").trim();
      const n = Number(v);
      return Number.isInteger(n) && n > 0 ? n : null;
    }
    function buildTestsJson() {
      coerceStateFromDOM();
      const filtered = tests.filter(hasContent);
      return { tests: filtered };
    }
    function buildQuestionPayload() {
      return {
        question_type: "standard_io",
        prompt: (promptEl.value || "").trim(),
        timeout_seconds: parsePositiveInt(timeoutEl),
        memory_limit_mb: parsePositiveInt(memoryEl),
        standard_io: {
          tests_json: buildTestsJson()
        }
      };
    }

    // ----- Validation -----
    function validateClient() {
      let ok = true; clearGlobalErrors();
      if (!promptEl.value.trim()) {
        ok = false; promptEl.classList.add("textarea-error");
        errPrompt.textContent = "Prompt is required."; errPrompt.classList.remove("hidden");
      }
      const tVal = parsePositiveInt(timeoutEl);
      const mVal = parsePositiveInt(memoryEl);
      if (tVal === null) { ok = false; timeoutEl.classList.add("input-error"); errTimeout.textContent = "Enter a positive integer."; errTimeout.classList.remove("hidden"); }
      if (mVal === null) { ok = false; memoryEl.classList.add("input-error"); errMemory.textContent = "Enter a positive integer."; errMemory.classList.remove("hidden"); }

      // tests validation
      const sections = sectionNodes();
      const nameCounts = {};
      sections.forEach((section) => {
        const nameEl = section.querySelector('[data-role="name"]');
        const name = (nameEl.value || "").trim();
        if (name) nameCounts[name] = (nameCounts[name] || 0) + 1;
      });

      let anyNeedsNewline = false;
      sections.forEach((section) => {
        clearInlineErrors(section);
        const nameEl = section.querySelector('[data-role="name"]');
        const stdoutEl = section.querySelector('[data-role="stdout"]');
        const name = (nameEl.value || "").trim();
        const rawStdout = (stdoutEl.value || "");
        const contentPresent = true; // tests are meaningful rows; enforce name+stdout
        if (!name) { ok = false; showFieldError(section, "name", "Test name is required."); }
        else if (nameCounts[name] > 1) { ok = false; showFieldError(section, "name", "Test name must be unique."); }
        if (contentPresent && rawStdout.trim().length === 0) { ok = false; showFieldError(section, "stdout", "stdout is required."); }
        if (rawStdout && !rawStdout.endsWith("\n")) anyNeedsNewline = true;
      });
      newlineBadge.classList.toggle("hidden", !anyNeedsNewline);
      return ok;
    }

    function applyServerErrors(errors) {
      clearGlobalErrors();
      if (!errors) return;
      if (errors.prompt) { promptEl.classList.add("textarea-error"); errPrompt.textContent = errors.prompt; errPrompt.classList.remove("hidden"); }
      if (errors.timeout_seconds) { timeoutEl.classList.add("input-error"); errTimeout.textContent = errors.timeout_seconds; errTimeout.classList.remove("hidden"); }
      if (errors.memory_limit_mb) { memoryEl.classList.add("input-error"); errMemory.textContent = errors.memory_limit_mb; errMemory.classList.remove("hidden"); }

      // tests errors: expect keys like tests[i].field
      sectionNodes().forEach(clearInlineErrors);
      Object.keys(errors || {}).forEach(k => {
        const m = k.match(/^tests\[(\d+)\]\.(name|stdout)$/);
        if (!m) return;
        const idx = Number(m[1]); const field = m[2];
        const section = sectionNodes()[idx]; if (!section) return;
        showFieldError(section, field, errors[k]);
      });
    }

    // ----- Preview -----
    function renderPreview() {
      const testsJson = buildTestsJson();
      const qPayload = buildQuestionPayload();
      testsPreview.textContent = JSON.stringify(testsJson, null, 2);
      questionPreview.textContent = JSON.stringify(qPayload, null, 2);
    }

    // ----- Events -----
    testsContainer.addEventListener("input", renderPreview);
    testsContainer.addEventListener("change", renderPreview);
    ["input", "change"].forEach(evt => {
      [promptEl, timeoutEl, memoryEl].forEach(el => el && el.addEventListener(evt, renderPreview));
    });

    testsContainer.addEventListener("click", function (e) {
      const section = e.target.closest("[data-test-index]");
      if (!section) return;
      const idx = parseInt(section.dataset.testIndex, 10);

      // Remove
      const removeBtn = e.target.closest("[data-action='removeTest']");
      if (removeBtn) {
        if (tests.length <= 1) return;
        tests.splice(idx, 1);
        tests = tests.map((t, i) => ({
          ...t,
          name: t.name && /^test\d+$/.test(t.name) ? `test${i + 1}` : t.name
        }));
        renderTests();
        renderPreview();
        return;
      }

      // Duplicate
      const dupBtn = e.target.closest("[data-action='duplicateTest']");
      if (dupBtn) {
        const nameEl = section.querySelector('[data-role="name"]');
        const stdinEl = section.querySelector('[data-role="stdin"]');
        const stdoutEl = section.querySelector('[data-role="stdout"]');
        const baseName = (nameEl.value || `test${idx + 1}`).trim();
        const newName = makeUniqueName(baseName || `test${idx + 1}`);
        const newTest = { name: newName, stdin: stdinEl.value || "", stdout: (stdoutEl.value || "") };
        tests.splice(idx + 1, 0, newTest);
        renderTests(); renderPreview();
        const newSection = sectionNodes()[idx + 1];
        const newNameInput = newSection?.querySelector('[data-role="name"]');
        if (newNameInput) newNameInput.focus();
      }
    });

    if (addTestBtn) {
      addTestBtn.addEventListener("click", function () {
        const next = tests.length + 1;
        tests.push({ name: `test${next}`, stdin: "", stdout: "" });
        renderTests(); renderPreview();
      });
    }

    // Copy tests JSON
    if (copyBtn) {
      copyBtn.addEventListener("click", async () => {
        try {
          await navigator.clipboard.writeText(testsPreview.textContent);
          show(toastEl);
        } catch {
          const tmp = document.createElement("textarea");
          tmp.value = testsPreview.textContent;
          document.body.appendChild(tmp);
          tmp.select();
          document.execCommand("copy");
          document.body.removeChild(tmp);
          show(toastEl);
        }
      });
    }

    // Validate tests (server): send ONLY tests_json
    if (validateBtn) {
      validateBtn.addEventListener("click", async () => {
        renderPreview();
        if (!validateClient()) { show(toastErr); return; }
        try {
          const res = await fetch("{% url 'standardio-validate' %}", {
            method: "POST",
            headers: { "Content-Type": "application/json", "X-CSRFToken": csrftoken },
            body: testsPreview.textContent
          });
          const data = await res.json().catch(() => ({}));
          if (res.ok && (data.ok || data.valid)) { show(toastOk); }
          else { applyServerErrors(data.errors || {}); show(toastErr); }
        } catch (e) {
          console.error(e); show(toastErr);
        }
      });
    }

    // Save — send FULL authoring payload
    if (saveBtn) {
      saveBtn.addEventListener("click", async () => {
        renderPreview();
        if (!validateClient()) { show(toastSaveErr); return; }

        const payload = buildQuestionPayload();
        if (currentQuestionId) payload.id = currentQuestionId;

        try {
          const url = new URL("{% url 'standardio-save' %}", window.location.origin);
          const res = await fetch(url.toString(), {
            method: "POST",
            headers: { "Content-Type": "application/json", "X-CSRFToken": csrftoken },
            body: JSON.stringify(payload)
          });
          const data = await res.json().catch(() => ({}));
          if (res.ok && data.ok) { currentQuestionId = data.id; show(toastSaveOk); }
          else { applyServerErrors(data.errors || {}); show(toastSaveErr); }
        } catch (e) {
          console.error(e); show(toastSaveErr);
        }
      });
    }

    // Initial render
    function renderTestsAndPreview() { renderTests(); renderPreview(); }
    renderTestsAndPreview();
  })();
</script>


{% endblock %}